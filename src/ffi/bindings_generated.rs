/* automatically generated by rust-bindgen 0.70.1 */

unsafe extern "C" {
    #[doc = " @brief\n This method will initialize the Sz processing object.  It must be called\n once per process, prior to any other calls.\n\n @param moduleName A name for the processing node, to help identify it within\n        system logs.\n @param iniParams A JSON string containing configuration parameters.\n @param initConfigID Identifier for the configuration to use in initialization.\n @param verboseLogging A flag to enable deeper logging of the Sz processing"]
    pub fn Sz_init(
        moduleName: *const libc::c_char,
        iniParams: *const libc::c_char,
        verboseLogging: i64,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_initWithConfigID(
        moduleName: *const libc::c_char,
        iniParams: *const libc::c_char,
        initConfigID: i64,
        verboseLogging: i64,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will re-initialize the Sz processing object."]
    pub fn Sz_reinit(initConfigID: i64) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will destroy and perform cleanup for the Sz processing object.  It\n should be called after all other calls are complete."]
    pub fn Sz_destroy() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method may optionally be called to pre-initialize some of the heavier weight\n internal resources of the Sz engine."]
    pub fn Sz_primeEngine() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Process a record contained in the internal redo-queue\n\n @param redoRecord Null terminated UT8-JSON record from Sz_getRedoRecord\n @param infoBuf Same as responseBuf. In a success, returns info about the\naffected entities\n @param infoBufSize Same as bufSize but for infoBuf\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer."]
    pub fn Sz_processRedoRecord(redoRecord: *const libc::c_char) -> i64;
}
unsafe extern "C" {
    pub fn Sz_processRedoRecordWithInfo(
        redoRecord: *const libc::c_char,
        infoBuf: *mut *mut libc::c_char,
        infoBufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve a record contained in the internal redo-queue\n\n @param responseBuf A memory buffer for returning the response document.\n        If an error occurred, an error response is stored here.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold at least this many bytes,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer."]
    pub fn Sz_getRedoRecord(
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Get the number of records contained in the internal redo-queue"]
    pub fn Sz_countRedoRecords() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method returns a JSON document that provides basic statistics on\n the requests made through the Sz object.  It returns things such as the\n number of records loaded, the duration of processing time, the number of\n retries made, etc.\n\n @param responseBuf A memory buffer for returning the response document.\n        If an error occurred, an error response is stored here.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold at least this many bytes,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer."]
    pub fn Sz_stats(
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method returns an identifier for the loaded Sz engine configuration\n\n @param configID The identifier value for the config."]
    pub fn Sz_getActiveConfigID(configID: *mut i64) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method is used to add entity data into the system.  This adds or\n updates a single entity observation record, by adding features for the\n observation.\n\n @param dataSourceCode The data source for the observation.\n @param recordID The ID for the record\n @param jsonData A JSON document containing the attribute information\n        for the observation.\n @param responseBuf A memory buffer for returning the response document.\n        If an error occurred, an error response is stored here.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold at least this many bytes,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the module transport is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_addRecord(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        jsonData: *const libc::c_char,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_addRecordWithInfo(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        jsonData: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Reevaluate an entity in the datastore."]
    pub fn Sz_reevaluateRecord(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_reevaluateEntity(entityID: i64, flags: i64) -> i64;
}
unsafe extern "C" {
    pub fn Sz_reevaluateRecordWithInfo(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_reevaluateEntityWithInfo(
        entityID: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method is used to delete observation data from the system.  This\n removes a single entity observation record, by removing all of its\n feature data and the observation itself.\n\n @param dataSourceCode The data source for the observation.\n @param recordID The ID for the record\n @param responseBuf A buffer that returns a JSON object that summaries the changes cased by adding the\n        record. Also contains the recordID.\n @param bufSize The size of the responseBuf buffer\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_deleteRecord(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_deleteRecordWithInfo(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method gives a similar data response to getRecord but you supply\n the record instead of it being loaded.\n\n @param jsonData A JSON document containing the information to examine\n @param responseBuf A memory buffer for returning the response document.\n        If an error occurred, an error response is stored here.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold at least this many bytes,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_getRecordPreview(
        jsonData: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method searches for entities that contain attribute information\n that are relevant to a set of input search attributes.\n\n @param jsonData A JSON document containing the attribute information\n        to search for\n @param responseBuf A memory buffer for returning the response document.\n        If an error occurred, an error response is stored here.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold at least this many bytes,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_searchByAttributes(
        jsonData: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_searchByAttributes_V2(
        jsonData: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_searchByAttributes_V3(
        jsonData: *const libc::c_char,
        searchProfile: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method is used to retrieve information about a specific resolved\n entity.  The information is returned as a JSON document.\n\n @param entityID The resolved entity to retrieve information for\n @param dataSourceCode The data source of the observation to search for\n @param recordID The record ID of the observation to search for\n @param responseBuf A memory buffer for returning the response document.\n        If an error occurred, an error response is stored here.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold at least this many bytes,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_getEntityByEntityID(
        entityID: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_getEntityByEntityID_V2(
        entityID: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_getEntityByRecordID(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_getEntityByRecordID_V2(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method is used to retrieve a stored record.\n\n @param dataSourceCode The data source of the observation to search for\n @param recordID The record ID of the observation to search for\n @param responseBuf A memory buffer for returning the response document.\n        If an error occurred, an error response is stored here.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold at least this many bytes,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_getRecord(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_getRecord_V2(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method is used to find a relationship path between entities.\n\n @param entityID1 The starting entity of the relationship path\n @param entityID2 The ending entity of the relationship path\n @param dataSourceCode1 The data source for the starting record of the relationship path\n @param recordID1 The record ID for the starting record of the relationship path\n @param dataSourceCode2 The data source for the ending record of the relationship path\n @param recordID2 The record ID for the ending record of the relationship path\n @param maxDegree The maximum degree of relationships to search\n @param responseBuf A memory buffer for returning the response document.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold the whole response message,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_findPathByEntityID(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityID_V2(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordID(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordID_V2(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method is used to find a relationship path between entities, that avoids\n a particular set of entities.\n\n @param entityID1 The starting entity of the relationship path\n @param entityID2 The ending entity of the relationship path\n @param dataSourceCode1 The data source for the starting record of the relationship path\n @param recordID1 The record ID for the starting record of the relationship path\n @param dataSourceCode2 The data source for the ending record of the relationship path\n @param recordID2 The record ID for the ending record of the relationship path\n @param maxDegree The maximum degree of relationships to search\n @param avoidedEntities A JSON document identifying the list of entities to\n        avoid in the path.\n        (example:  {\"ENTITIES\":[{\"ENTITY_ID\":\"6\"},{\"ENTITY_ID\":\"11\"},{\"ENTITY_ID\":\"9\"}]} )\n @param avoidedRecords A JSON document identifying the list of records for\n        entities to avoid in the path.\n        (example:\n {\"RECORDS\":[{\"DATA_SOURCE\":\"PEOPLE\",\"RECORD_ID\":\"1504\"},{\"DATA_SOURCE\":\"PEOPLE\",\"RECORD_ID\":\"1507\"}]} )\n @param flags A bit mask specifying control flags, such as\n        \"SZ_FIND_PATH_STRICT_AVOID\".  The default and recommended\n        value is \"SZ_FIND_PATH_DEFAULT_FLAGS\".\n @param responseBuf A memory buffer for returning the response document.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold the whole response message,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_findPathByEntityIDWithAvoids(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        avoidedEntities: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityIDWithAvoids_V2(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        avoidedEntities: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordIDWithAvoids(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        avoidedRecords: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordIDWithAvoids_V2(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        avoidedRecords: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method is used to find a relationship path between entities, that avoids\n a particular set of entities, and also requires at least one data source from a\n set to be part of the path.\n\n @param entityID1 The starting entity of the relationship path\n @param entityID2 The ending entity of the relationship path\n @param dataSourceCode1 The data source for the starting record of the relationship path\n @param recordID1 The record ID for the starting record of the relationship path\n @param dataSourceCode2 The data source for the ending record of the relationship path\n @param recordID2 The record ID for the ending record of the relationship path\n @param maxDegree The maximum degree of relationships to search\n @param avoidedEntities A JSON document identifying the list of entities to\n        avoid in the path.\n        (example:  {\"ENTITIES\":[{\"ENTITY_ID\":\"6\"},{\"ENTITY_ID\":\"11\"},{\"ENTITY_ID\":\"9\"}]} )\n @param avoidedRecords A JSON document identifying the list of records for\n        entities to avoid in the path.\n        (example:\n {\"RECORDS\":[{\"DATA_SOURCE\":\"PEOPLE\",\"RECORD_ID\":\"1504\"},{\"DATA_SOURCE\":\"PEOPLE\",\"RECORD_ID\":\"1507\"}]} )\n @param requiredDsrcs A JSON document identifying the list of data sources to watch for\n        (example:  {\"DATA_SOURCES\":[\"PEOPLE\",\"COMPANIES\"]} )\n @param flags A bit mask specifying control flags, such as\n        \"SZ_FIND_PATH_STRICT_AVOID\".  The default and recommended\n        value is \"SZ_FIND_PATH_DEFAULT_FLAGS\".\n @param responseBuf A memory buffer for returning the response document.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold the whole response message,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_findPathByEntityIDIncludingSource(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        avoidedEntities: *const libc::c_char,
        requiredDsrcs: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityIDIncludingSource_V2(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        avoidedEntities: *const libc::c_char,
        requiredDsrcs: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordIDIncludingSource(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        avoidedRecords: *const libc::c_char,
        requiredDsrcs: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordIDIncludingSource_V2(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        avoidedRecords: *const libc::c_char,
        requiredDsrcs: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method is used to find a network of entity relationships, surrounding the paths between\n a set of entities.\n\n @param entityList A JSON document identifying the list of entities to\n        find paths between and a network around.\n        (example:  {\"ENTITIES\":[{\"ENTITY_ID\":\"6\"},{\"ENTITY_ID\":\"11\"},{\"ENTITY_ID\":\"9\"}]} )\n @param recordList A JSON document identifying the list of record entities to\n        find paths between and a network around.\n        (example:\n {\"RECORDS\":[{\"DATA_SOURCE\":\"PEOPLE\",\"RECORD_ID\":\"1504\"},{\"DATA_SOURCE\":\"PEOPLE\",\"RECORD_ID\":\"1507\"},{\"DATA_SOURCE\":\"PEOPLE\",\"RECORD_ID\":\"1510\"}]}\n )\n @param maxDegree The maximum degree of relationships to search for a path\n @param buildOutDegree The maximum degree of relationships to include in the network\n        around each entity\n @param maxEntities The maximum number of entities to return\n @param responseBuf A memory buffer for returning the response document.\n @param bufSize The max number of bytes that can be stored in responseBuf.\n        The response buffer must be able to hold the whole response message,\n        or a resize method must be provided that may be used to resize\n        the buffer.  This will return the new size.\n @param resizeFunc A function pointer that can be used to resize the memory\n        buffer specified in the responseBuf argument.  This function will\n        be called to allocate more memory if the response buffer is not large\n        enough.  This argument may be NULL.  If it is NULL, the function\n        will return an error if the result is larger than the buffer.\n @return Returns 0 for success. Returns -1 if the response status indicates\n         failure or the Sz module is not initialized. Returns -2 if\n         an exception was thrown and caught."]
    pub fn Sz_findNetworkByEntityID(
        entityList: *const libc::c_char,
        maxDegree: i64,
        buildOutDegree: i64,
        maxEntities: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findNetworkByEntityID_V2(
        entityList: *const libc::c_char,
        maxDegree: i64,
        buildOutDegree: i64,
        maxEntities: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findNetworkByRecordID(
        recordList: *const libc::c_char,
        maxDegree: i64,
        buildOutDegree: i64,
        maxEntities: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findNetworkByRecordID_V2(
        recordList: *const libc::c_char,
        maxDegree: i64,
        buildOutDegree: i64,
        maxEntities: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method determines what interesting entities exist around a particular resolved entity"]
    pub fn Sz_findInterestingEntitiesByEntityID(
        entityID: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_findInterestingEntitiesByRecordID(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method determines why a particular record is included in its resolved entity."]
    pub fn Sz_whyRecordInEntity(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_whyRecordInEntity_V2(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method determines how records are related to each other."]
    pub fn Sz_whyRecords(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_whyRecords_V2(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method determines how entities are related to each other."]
    pub fn Sz_whyEntities(
        entityID1: i64,
        entityID2: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_whyEntities_V2(
        entityID1: i64,
        entityID2: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method determines how a search record relates to an existing entity."]
    pub fn Sz_whySearch(
        jsonData: *const libc::c_char,
        entityID: i64,
        searchProfile: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_whySearch_V2(
        jsonData: *const libc::c_char,
        entityID: i64,
        searchProfile: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method gives information on how entities were constructed from their base records."]
    pub fn Sz_howEntityByEntityID(
        entityID: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_howEntityByEntityID_V2(
        entityID: i64,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method gives information on how an entity composed of a given set of records would look"]
    pub fn Sz_getVirtualEntityByRecordID(
        recordList: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn Sz_getVirtualEntityByRecordID_V2(
        recordList: *const libc::c_char,
        flags: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
pub type ExportHandle = usize;
unsafe extern "C" {
    #[doc = " @brief\n This is used to export entity data from known entities.  This function\n returns an export-handle that can be read from to get the export data\n in JSON format.  The export-handle should be read using the \"Sz_fetchNext\"\n function, and closed when work is complete. Each output row contains the\n exported entity data for a single resolved entity.\n\n @param flags A bit mask specifying control flags, such as\n        \"SZ_EXPORT_INCLUDE_SINGLE_RECORD_ENTITIES\".  The default and recommended\n        value is \"SZ_EXPORT_DEFAULT_FLAGS\".\n\n @return Returns an export handle that the entity data can be read from."]
    pub fn Sz_exportJSONEntityReport(flags: i64, responseHandle: *mut ExportHandle) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This is used to export entity data from known entities.  This function\n returns an export-handle that can be read from to get the export data\n in CSV format.  The export-handle should be read using the \"Sz_fetchNext\"\n function, and closed when work is complete. The first output row returned\n by the export-handle contains the JSON column headers as a string.  Each\n following row contains the exported entity data.\n\n @param flags A bit mask specifying other control flags, such as\n        \"SZ_EXPORT_INCLUDE_SINGLE_RECORD_ENTITIES\".  The default and recommended\n        value is \"SZ_EXPORT_DEFAULT_FLAGS\".\n\n @return Returns an export handle that the entity data can be read from."]
    pub fn Sz_exportCSVEntityReport(
        csvColumnList: *const libc::c_char,
        flags: i64,
        responseHandle: *mut ExportHandle,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function is used to read entity data from an export handle,\n one data row at a time.\n\n @param responseHandle The export handle to retrieve data from\n @param responseBuf The buffer to write the string data to\n @param bufSize The size of the response buffer\n\n @return Returns a pointer to the buffer if successful, or -1 otherwise"]
    pub fn Sz_fetchNext(
        responseHandle: ExportHandle,
        responseBuf: *mut libc::c_char,
        bufSize: usize,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function closes an export handle, to clean up system resources."]
    pub fn Sz_closeExportReport(responseHandle: ExportHandle) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the last exception thrown in the engine\n @return number of bytes copied into buffer"]
    pub fn Sz_getLastException(buffer: *mut libc::c_char, bufSize: usize) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the code of the last exception thrown in the engine\n @return number of bytes copied into buffer"]
    pub fn Sz_getLastExceptionCode() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function clears the last exception thrown in libSz"]
    pub fn Sz_clearLastException();
}
unsafe extern "C" {
    pub fn SzHelper_free(p: *mut libc::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzConfig_registerDataSource_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzConfig_registerDataSource_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SzConfig_create_result {
    pub response: usize,
    pub returnCode: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzConfig_getDataSourceRegistry_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzConfig_getDataSourceRegistry_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzConfig_load_result {
    pub response: *mut libc::c_void,
    pub returnCode: i64,
}
impl Default for SzConfig_load_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzConfig_export_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzConfig_export_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn SzConfig_registerDataSource_helper(
        configHandle: usize,
        inputJson: *const libc::c_char,
    ) -> SzConfig_registerDataSource_result;
}
unsafe extern "C" {
    pub fn SzConfig_close_helper(configHandle: usize) -> i64;
}
unsafe extern "C" {
    pub fn SzConfig_create_helper() -> SzConfig_create_result;
}
unsafe extern "C" {
    pub fn SzConfig_unregisterDataSource_helper(
        configHandle: usize,
        inputJson: *const libc::c_char,
    ) -> i64;
}
unsafe extern "C" {
    pub fn SzConfig_getDataSourceRegistry_helper(
        configHandle: usize,
    ) -> SzConfig_getDataSourceRegistry_result;
}
unsafe extern "C" {
    pub fn SzConfig_load_helper(inputJson: *const libc::c_char) -> SzConfig_load_result;
}
unsafe extern "C" {
    pub fn SzConfig_export_helper(configHandle: usize) -> SzConfig_export_result;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SzConfigMgr_registerConfig_result {
    pub configID: i64,
    pub returnCode: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzConfigMgr_getConfig_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzConfigMgr_getConfig_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzConfigMgr_getConfigRegistry_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzConfigMgr_getConfigRegistry_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SzConfigMgr_getDefaultConfigID_result {
    pub configID: i64,
    pub returnCode: i64,
}
unsafe extern "C" {
    pub fn SzConfigMgr_registerConfig_helper(
        configStr: *const libc::c_char,
        configComments: *const libc::c_char,
    ) -> SzConfigMgr_registerConfig_result;
}
unsafe extern "C" {
    pub fn SzConfigMgr_getConfig_helper(configID: i64) -> SzConfigMgr_getConfig_result;
}
unsafe extern "C" {
    pub fn SzConfigMgr_getConfigRegistry_helper() -> SzConfigMgr_getConfigRegistry_result;
}
unsafe extern "C" {
    pub fn SzConfigMgr_getDefaultConfigID_helper() -> SzConfigMgr_getDefaultConfigID_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzDiagnostic_checkRepositoryPerformance_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzDiagnostic_checkRepositoryPerformance_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn SzDiagnostic_checkRepositoryPerformance_helper(
        secondsToRun: i64,
    ) -> SzDiagnostic_checkRepositoryPerformance_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzDiagnostic_getRepositoryInfo_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzDiagnostic_getRepositoryInfo_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn SzDiagnostic_getRepositoryInfo_helper() -> SzDiagnostic_getRepositoryInfo_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzDiagnostic_getFeature_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzDiagnostic_getFeature_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    #[doc = " THIS FUNCTION IS UNSUPPORTED AND UNDOCUMENTED.  ANY USE IS WITHOUT WARRANTY OF ANY KIND."]
    pub fn SzDiagnostic_getFeature_helper(libFeatId: i64) -> SzDiagnostic_getFeature_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_addRecordWithInfo_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_addRecordWithInfo_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_processRedoRecordWithInfo_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_processRedoRecordWithInfo_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_deleteRecordWithInfo_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_deleteRecordWithInfo_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Sz_exportCSVEntityReport_result {
    pub exportHandle: usize,
    pub returnCode: i64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Sz_exportJSONEntityReport_result {
    pub exportHandle: usize,
    pub returnCode: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_fetchNext_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_fetchNext_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findInterestingEntitiesByEntityID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findInterestingEntitiesByEntityID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findInterestingEntitiesByRecordID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findInterestingEntitiesByRecordID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findNetworkByEntityID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findNetworkByEntityID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findNetworkByEntityID_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findNetworkByEntityID_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findNetworkByRecordID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findNetworkByRecordID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findNetworkByRecordID_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findNetworkByRecordID_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByEntityID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByEntityID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByEntityID_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByEntityID_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByRecordID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByRecordID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByRecordID_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByRecordID_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByEntityIDWithAvoids_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByEntityIDWithAvoids_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByEntityIDWithAvoids_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByEntityIDWithAvoids_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByRecordIDWithAvoids_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByRecordIDWithAvoids_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByRecordIDWithAvoids_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByRecordIDWithAvoids_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByEntityIDIncludingSource_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByEntityIDIncludingSource_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByEntityIDIncludingSource_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByEntityIDIncludingSource_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByRecordIDIncludingSource_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByRecordIDIncludingSource_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_findPathByRecordIDIncludingSource_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_findPathByRecordIDIncludingSource_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct Sz_getActiveConfigID_result {
    pub configID: i64,
    pub returnCode: i64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getEntityByEntityID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getEntityByEntityID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getEntityByEntityID_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getEntityByEntityID_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getEntityByRecordID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getEntityByRecordID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getEntityByRecordID_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getEntityByRecordID_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getRecord_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getRecord_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getRecord_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getRecord_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getRedoRecord_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getRedoRecord_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getVirtualEntityByRecordID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getVirtualEntityByRecordID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getVirtualEntityByRecordID_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getVirtualEntityByRecordID_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_howEntityByEntityID_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_howEntityByEntityID_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_howEntityByEntityID_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_howEntityByEntityID_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_reevaluateEntityWithInfo_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_reevaluateEntityWithInfo_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_reevaluateRecordWithInfo_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_reevaluateRecordWithInfo_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_getRecordPreview_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_getRecordPreview_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_searchByAttributes_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_searchByAttributes_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_searchByAttributes_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_searchByAttributes_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_searchByAttributes_V3_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_searchByAttributes_V3_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_stats_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_stats_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_whySearch_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_whySearch_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_whySearch_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_whySearch_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_whyEntities_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_whyEntities_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_whyEntities_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_whyEntities_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_whyRecords_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_whyRecords_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_whyRecords_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_whyRecords_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_whyRecordInEntity_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_whyRecordInEntity_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sz_whyRecordInEntity_V2_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for Sz_whyRecordInEntity_V2_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn Sz_addRecordWithInfo_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        jsonData: *const libc::c_char,
        flags: i64,
    ) -> Sz_addRecordWithInfo_result;
}
unsafe extern "C" {
    pub fn Sz_processRedoRecordWithInfo_helper(
        jsonData: *const libc::c_char,
    ) -> Sz_processRedoRecordWithInfo_result;
}
unsafe extern "C" {
    pub fn Sz_closeExportReport_helper(responseHandle: usize) -> i64;
}
unsafe extern "C" {
    pub fn Sz_deleteRecordWithInfo_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
    ) -> Sz_deleteRecordWithInfo_result;
}
unsafe extern "C" {
    pub fn Sz_exportCSVEntityReport_helper(
        csvColumnList: *const libc::c_char,
        flags: i64,
    ) -> Sz_exportCSVEntityReport_result;
}
unsafe extern "C" {
    pub fn Sz_exportJSONEntityReport_helper(flags: i64) -> Sz_exportJSONEntityReport_result;
}
unsafe extern "C" {
    pub fn Sz_findInterestingEntitiesByEntityID_helper(
        entityID: i64,
        flags: i64,
    ) -> Sz_findInterestingEntitiesByEntityID_result;
}
unsafe extern "C" {
    pub fn Sz_findInterestingEntitiesByRecordID_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
    ) -> Sz_findInterestingEntitiesByRecordID_result;
}
unsafe extern "C" {
    pub fn Sz_findNetworkByEntityID_helper(
        entityList: *const libc::c_char,
        maxDegree: i64,
        buildOutDegree: i64,
        maxEntities: i64,
    ) -> Sz_findNetworkByEntityID_result;
}
unsafe extern "C" {
    pub fn Sz_findNetworkByEntityID_V2_helper(
        entityList: *const libc::c_char,
        maxDegree: i64,
        buildOutDegree: i64,
        maxEntities: i64,
        flags: i64,
    ) -> Sz_findNetworkByEntityID_V2_result;
}
unsafe extern "C" {
    pub fn Sz_findNetworkByRecordID_helper(
        recordList: *const libc::c_char,
        maxDegree: i64,
        buildOutDegree: i64,
        maxEntities: i64,
    ) -> Sz_findNetworkByRecordID_result;
}
unsafe extern "C" {
    pub fn Sz_findNetworkByRecordID_V2_helper(
        recordList: *const libc::c_char,
        maxDegree: i64,
        buildOutDegree: i64,
        maxEntities: i64,
        flags: i64,
    ) -> Sz_findNetworkByRecordID_V2_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityID_helper(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
    ) -> Sz_findPathByEntityID_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityID_V2_helper(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        flags: i64,
    ) -> Sz_findPathByEntityID_V2_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordID_helper(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
    ) -> Sz_findPathByRecordID_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordID_V2_helper(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        flags: i64,
    ) -> Sz_findPathByRecordID_V2_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityIDWithAvoids_helper(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        avoidedEntities: *const libc::c_char,
    ) -> Sz_findPathByEntityIDWithAvoids_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityIDWithAvoids_V2_helper(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        avoidedEntities: *const libc::c_char,
        flags: i64,
    ) -> Sz_findPathByEntityIDWithAvoids_V2_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordIDWithAvoids_helper(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        avoidedRecords: *const libc::c_char,
    ) -> Sz_findPathByRecordIDWithAvoids_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordIDWithAvoids_V2_helper(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        avoidedRecords: *const libc::c_char,
        flags: i64,
    ) -> Sz_findPathByRecordIDWithAvoids_V2_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityIDIncludingSource_helper(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        avoidedEntities: *const libc::c_char,
        requiredDsrcs: *const libc::c_char,
    ) -> Sz_findPathByEntityIDIncludingSource_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByEntityIDIncludingSource_V2_helper(
        entityID1: i64,
        entityID2: i64,
        maxDegree: i64,
        avoidedEntities: *const libc::c_char,
        requiredDsrcs: *const libc::c_char,
        flags: i64,
    ) -> Sz_findPathByEntityIDIncludingSource_V2_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordIDIncludingSource_helper(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        avoidedRecords: *const libc::c_char,
        requiredDsrcs: *const libc::c_char,
    ) -> Sz_findPathByRecordIDIncludingSource_result;
}
unsafe extern "C" {
    pub fn Sz_findPathByRecordIDIncludingSource_V2_helper(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        maxDegree: i64,
        avoidedRecords: *const libc::c_char,
        requiredDsrcs: *const libc::c_char,
        flags: i64,
    ) -> Sz_findPathByRecordIDIncludingSource_V2_result;
}
unsafe extern "C" {
    pub fn Sz_fetchNext_helper(exportHandle: usize) -> Sz_fetchNext_result;
}
unsafe extern "C" {
    pub fn Sz_getActiveConfigID_helper() -> Sz_getActiveConfigID_result;
}
unsafe extern "C" {
    pub fn Sz_getEntityByEntityID_helper(entityID: i64) -> Sz_getEntityByEntityID_result;
}
unsafe extern "C" {
    pub fn Sz_getEntityByEntityID_V2_helper(
        entityID: i64,
        flags: i64,
    ) -> Sz_getEntityByEntityID_V2_result;
}
unsafe extern "C" {
    pub fn Sz_getEntityByRecordID_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
    ) -> Sz_getEntityByRecordID_result;
}
unsafe extern "C" {
    pub fn Sz_getEntityByRecordID_V2_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
    ) -> Sz_getEntityByRecordID_V2_result;
}
unsafe extern "C" {
    pub fn Sz_getRecord_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
    ) -> Sz_getRecord_result;
}
unsafe extern "C" {
    pub fn Sz_getRecord_V2_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
    ) -> Sz_getRecord_V2_result;
}
unsafe extern "C" {
    pub fn Sz_getRedoRecord_helper() -> Sz_getRedoRecord_result;
}
unsafe extern "C" {
    pub fn Sz_getVirtualEntityByRecordID_helper(
        recordList: *const libc::c_char,
    ) -> Sz_getVirtualEntityByRecordID_result;
}
unsafe extern "C" {
    pub fn Sz_getVirtualEntityByRecordID_V2_helper(
        recordList: *const libc::c_char,
        flags: i64,
    ) -> Sz_getVirtualEntityByRecordID_V2_result;
}
unsafe extern "C" {
    pub fn Sz_howEntityByEntityID_helper(entityID: i64) -> Sz_howEntityByEntityID_result;
}
unsafe extern "C" {
    pub fn Sz_howEntityByEntityID_V2_helper(
        entityID: i64,
        flags: i64,
    ) -> Sz_howEntityByEntityID_V2_result;
}
unsafe extern "C" {
    pub fn Sz_reevaluateEntityWithInfo_helper(
        entityID: i64,
        flags: i64,
    ) -> Sz_reevaluateEntityWithInfo_result;
}
unsafe extern "C" {
    pub fn Sz_reevaluateRecordWithInfo_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
    ) -> Sz_reevaluateRecordWithInfo_result;
}
unsafe extern "C" {
    pub fn Sz_getRecordPreview_helper(
        jsonData: *const libc::c_char,
        flags: i64,
    ) -> Sz_getRecordPreview_result;
}
unsafe extern "C" {
    pub fn Sz_searchByAttributes_helper(
        jsonData: *const libc::c_char,
    ) -> Sz_searchByAttributes_result;
}
unsafe extern "C" {
    pub fn Sz_searchByAttributes_V2_helper(
        jsonData: *const libc::c_char,
        flags: i64,
    ) -> Sz_searchByAttributes_V2_result;
}
unsafe extern "C" {
    pub fn Sz_searchByAttributes_V3_helper(
        jsonData: *const libc::c_char,
        profile: *const libc::c_char,
        flags: i64,
    ) -> Sz_searchByAttributes_V3_result;
}
unsafe extern "C" {
    pub fn Sz_stats_helper() -> Sz_stats_result;
}
unsafe extern "C" {
    pub fn Sz_whySearch_helper(
        jsonData: *const libc::c_char,
        entityID: i64,
        searchProfile: *const libc::c_char,
    ) -> Sz_whySearch_result;
}
unsafe extern "C" {
    pub fn Sz_whySearch_V2_helper(
        jsonData: *const libc::c_char,
        entityID: i64,
        searchProfile: *const libc::c_char,
        flags: i64,
    ) -> Sz_whySearch_V2_result;
}
unsafe extern "C" {
    pub fn Sz_whyEntities_helper(entityID1: i64, entityID2: i64) -> Sz_whyEntities_result;
}
unsafe extern "C" {
    pub fn Sz_whyEntities_V2_helper(
        entityID1: i64,
        entityID2: i64,
        flags: i64,
    ) -> Sz_whyEntities_V2_result;
}
unsafe extern "C" {
    pub fn Sz_whyRecords_helper(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
    ) -> Sz_whyRecords_result;
}
unsafe extern "C" {
    pub fn Sz_whyRecords_V2_helper(
        dataSourceCode1: *const libc::c_char,
        recordID1: *const libc::c_char,
        dataSourceCode2: *const libc::c_char,
        recordID2: *const libc::c_char,
        flags: i64,
    ) -> Sz_whyRecords_V2_result;
}
unsafe extern "C" {
    pub fn Sz_whyRecordInEntity_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
    ) -> Sz_whyRecordInEntity_result;
}
unsafe extern "C" {
    pub fn Sz_whyRecordInEntity_V2_helper(
        dataSourceCode: *const libc::c_char,
        recordID: *const libc::c_char,
        flags: i64,
    ) -> Sz_whyRecordInEntity_V2_result;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzProduct_validateLicenseFile_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzProduct_validateLicenseFile_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SzProduct_validateLicenseStringBase64_result {
    pub response: *mut libc::c_char,
    pub returnCode: i64,
}
impl Default for SzProduct_validateLicenseStringBase64_result {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
unsafe extern "C" {
    pub fn SzProduct_validateLicenseFile_helper(
        licenseFilePath: *const libc::c_char,
    ) -> SzProduct_validateLicenseFile_result;
}
unsafe extern "C" {
    pub fn SzProduct_validateLicenseStringBase64_helper(
        licenseString: *const libc::c_char,
    ) -> SzProduct_validateLicenseStringBase64_result;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will initialize the SzConfig object.  It must be called\n prior to any other calls.\n\n @param moduleName A name for the engine node, to help identify it within\n        system logs.\n @param iniParams A JSON string containing configuration parameters.\n @param verboseLogging A flag to enable deeper logging of the Sz processing"]
    pub fn SzConfig_init(
        moduleName: *const libc::c_char,
        iniParams: *const libc::c_char,
        verboseLogging: i64,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will destroy and perform cleanup for the Sz Config object.  It\n should be called after all other calls are complete."]
    pub fn SzConfig_destroy() -> i64;
}
pub type ConfigHandle = *mut libc::c_void;
unsafe extern "C" {
    #[doc = " @brief\n This method creates a stock Sz JSON config from the template config"]
    pub fn SzConfig_create(configHandle: *mut ConfigHandle) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method initializes the SzConfig object from a JSON string.  Any time you need to edit an existing\n config from an existing repository you will want to use this method to be able to modify it."]
    pub fn SzConfig_load(jsonConfig: *const libc::c_char, configHandle: *mut ConfigHandle) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method saves the SzConfig object into a JSON string."]
    pub fn SzConfig_export(
        configHandle: ConfigHandle,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method cleans up the SzConfig object pointed to by the handle."]
    pub fn SzConfig_close(configHandle: ConfigHandle) -> i64;
}
unsafe extern "C" {
    pub fn SzConfig_getDataSourceRegistry(
        configHandle: ConfigHandle,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn SzConfig_registerDataSource(
        configHandle: ConfigHandle,
        inputJson: *const libc::c_char,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn SzConfig_unregisterDataSource(
        configHandle: ConfigHandle,
        inputJson: *const libc::c_char,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the last exception thrown in SzConfig\n @return number of bytes copied into buffer"]
    pub fn SzConfig_getLastException(buffer: *mut libc::c_char, bufSize: usize) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the code of the last exception thrown in SzConfig\n @return number of bytes copied into buffer"]
    pub fn SzConfig_getLastExceptionCode() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function clears the last exception thrown in SzConfig"]
    pub fn SzConfig_clearLastException();
}
unsafe extern "C" {
    #[doc = " @brief\n This method will initialize the Sz Config Manager object.  It must be called\n prior to any other calls.\n\n @param moduleName A name for the node, to help identify it within\n        system logs.\n @param iniParams A JSON string specifying the configuration parameters\n @param verboseLogging A flag to enable deeper logging of the Sz processing"]
    pub fn SzConfigMgr_init(
        moduleName: *const libc::c_char,
        iniParams: *const libc::c_char,
        verboseLogging: i64,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will destroy and perform cleanup for the Sz Config object.  It\n should be called after all other calls are complete."]
    pub fn SzConfigMgr_destroy() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Registers a configuration handle with the backend data store"]
    pub fn SzConfigMgr_registerConfig(
        configStr: *const libc::c_char,
        configComments: *const libc::c_char,
        configID: *mut i64,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve configuration information from the backend data store"]
    pub fn SzConfigMgr_getConfig(
        configID: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Retrieve a list of configurations from the backend data store"]
    pub fn SzConfigMgr_getConfigRegistry(
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Set the default configuration identifier in the backend data store"]
    pub fn SzConfigMgr_setDefaultConfigID(configID: i64) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Get the default configuration identifier from the backend data store"]
    pub fn SzConfigMgr_getDefaultConfigID(configID: *mut i64) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Replace the default configuration identifier in the backend data store"]
    pub fn SzConfigMgr_replaceDefaultConfigID(oldConfigID: i64, newConfigID: i64) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the last exception thrown in SzConfigMgr\n @return number of bytes copied into buffer"]
    pub fn SzConfigMgr_getLastException(buffer: *mut libc::c_char, bufSize: usize) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the code of the last exception thrown in SzConfigMgr\n @return number of bytes copied into buffer"]
    pub fn SzConfigMgr_getLastExceptionCode() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function clears the last exception thrown in SzConfigMgr"]
    pub fn SzConfigMgr_clearLastException();
}
unsafe extern "C" {
    #[doc = " @brief\n This method will initialize the Sz diagnostic object.  It must be called\n prior to any other calls.\n\n @param moduleName A name for the diagnostic node, to help identify it within\n        system logs.\n @param iniParams A JSON string specifying the configuration parameters\n @param verboseLogging A flag to enable deeper logging of the Sz processing"]
    pub fn SzDiagnostic_init(
        moduleName: *const libc::c_char,
        iniParams: *const libc::c_char,
        verboseLogging: i64,
    ) -> i64;
}
unsafe extern "C" {
    pub fn SzDiagnostic_initWithConfigID(
        moduleName: *const libc::c_char,
        iniParams: *const libc::c_char,
        initConfigID: i64,
        verboseLogging: i64,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will re-initialize the Sz diagnostic object."]
    pub fn SzDiagnostic_reinit(initConfigID: i64) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will destroy and perform cleanup for the Sz diagnostic object.  It\n should be called after all other calls are complete."]
    pub fn SzDiagnostic_destroy() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This is used to purge all data from an existing repository\n @return Returns 0 for success, or an appropriate error code."]
    pub fn SzDiagnostic_purgeRepository() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief Check the performance metrics of the datastore"]
    pub fn SzDiagnostic_checkRepositoryPerformance(
        secondsToRun: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn SzDiagnostic_getRepositoryInfo(
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the last exception thrown in SzDiagnostic\n @return number of bytes copied into buffer"]
    pub fn SzDiagnostic_getLastException(buffer: *mut libc::c_char, bufSize: usize) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the code of the last exception thrown in SzDiagnostic\n @return number of bytes copied into buffer"]
    pub fn SzDiagnostic_getLastExceptionCode() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function clears the last exception thrown in SzDiagnostic"]
    pub fn SzDiagnostic_clearLastException();
}
unsafe extern "C" {
    #[doc = " THESE FUNCTIONS ARE UNSUPPORTED AND UNDOCUMENTED.  ANY USE IS WITHOUT WARRANTY OF ANY KIND."]
    pub fn SzDiagnostic_getFeature(
        libFeatID: i64,
        responseBuf: *mut *mut libc::c_char,
        bufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will initialize the Sz product object.  It must be called\n prior to any other calls.\n\n @param moduleName A name for the node, to help identify it within\n        system logs.\n @param iniParams A JSON string specifying the configuration parameters\n @param verboseLogging A flag to enable deeper logging of the Sz processing"]
    pub fn SzProduct_init(
        moduleName: *const libc::c_char,
        iniParams: *const libc::c_char,
        verboseLogging: i64,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This method will destroy and perform cleanup for the Sz product object.  It\n should be called after all other calls are complete."]
    pub fn SzProduct_destroy() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function is used to return the license information\n\n @return Returns a pointer to the license information in JSON format"]
    pub fn SzProduct_getLicense() -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " @brief\n This function is used to validate an external license file for validity.\n If it is not valid, information on why will be returned through the\n error buffer parameters.\n\n These functions do not require SzProduct to be initialized.\n\n @param licenseFilePath The file path and name of the file to validate.\n @param errorBuf The buffer to write an error message to\n @param errorBufSize The size of the error buffer\n @param resizeFunc A function to resize the error buffer, if it needs more space.\n\n @return 0 if the file is a valid license."]
    pub fn SzProduct_validateLicenseFile(
        licenseFilePath: *const libc::c_char,
        errorBuf: *mut *mut libc::c_char,
        errorBufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    pub fn SzProduct_validateLicenseStringBase64(
        licenseString: *const libc::c_char,
        errorBuf: *mut *mut libc::c_char,
        errorBufSize: *mut usize,
        resizeFunc: ::core::option::Option<
            unsafe extern "C" fn(ptr: *mut libc::c_void, newSize: usize) -> *mut libc::c_void,
        >,
    ) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function is used to return the version and build information\n\n This function does not require SzProduct to be initialized.\n\n @return Returns a pointer to the version and build information in JSON format"]
    pub fn SzProduct_getVersion() -> *mut libc::c_char;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the last exception thrown in SzProduct\n @return number of bytes copied into buffer"]
    pub fn SzProduct_getLastException(buffer: *mut libc::c_char, bufSize: usize) -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function retrieves the code of the last exception thrown in SzProduct\n @return number of bytes copied into buffer"]
    pub fn SzProduct_getLastExceptionCode() -> i64;
}
unsafe extern "C" {
    #[doc = " @brief\n This function clears the last exception thrown in SzProduct"]
    pub fn SzProduct_clearLastException();
}
